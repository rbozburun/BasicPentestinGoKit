package actions

// TO DO
//
// Implement dirlisting, loginpagefinder, tracedetector, usedserverdetector functions.

import (
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/PuerkitoBio/goquery"
)

var (
	outfile, _ = os.Create("gokit.log") // update path for your needs
	l          = log.New(outfile, "", log.LstdFlags|log.Lshortfile)
	targetUrl  = ""
)

func errCheck(err error) {
	if err != nil {
		fmt.Println(err)
	}
}

// Checks url if suffix "/", if not adds it.
func createRootURL(target string) {
	if targetUrl == "" {
		last := target[len(target)-1:]
		// Check the URL includes "/"
		if last != "/" {
			target = (target + "/")
		}

		targetUrl = target
		l.Println("Target URL created: " + target)
	}

}

// TO DO
// HSTS Header
//
// Vulnerabilities array and summary
func CrossdomainFlag(target string) {
	createRootURL(target)
	l.Println("[INFO] Attacking for Crossdomain.xml file.")

	crossd_url := targetUrl + "crossdomain.xml"
	resp, err := http.Get(crossd_url)
	errCheck(err)
	if resp.StatusCode > 400 {
		resp, err = http.Get(crossd_url)
		errCheck(err)
	}

	if resp.StatusCode > 400 {
		fmt.Println("[!] Status code: " + strconv.Itoa(resp.StatusCode) + " | Crossdomain.xml Couldn't Find!")
		l.Printf("[WARN] Couldn't load page - HTTP Status: %d - CrossdomainChecker Passed", resp.StatusCode)
	} else if resp.StatusCode == 200 {
		fmt.Println("[i] Crossdomain found: " + crossd_url)

		doc, err := goquery.NewDocumentFromReader(resp.Body)
		errCheck(err)

		body := doc.Find("body")
		html, err := body.Html()
		errCheck(err)
		// Check the body  allows access from all domains.
		if strings.Contains(html, "<allow-access-from domain=\"*\"") {
			fmt.Println("[+] Crossdomain Policy Misconfiguration detected: " + crossd_url)
			l.Printf("[VULN] Crossdomain Policy Misconfiguration detected: " + crossd_url)
		}

	} else {
		fmt.Println("[i] Redirection detected. Crossdomain file couldn't find.")
		l.Printf("[WARN] Couldn't load page - HTTP Status: %d - Possible Redirection [CrossdomainChecker]", resp.StatusCode)
	}

}

func DirListing(target string) {
	createRootURL(target)
	l.Println("[INFO] Attacking for Directory Listing Vulnerability")

	resp, err := http.Get(targetUrl)
	errCheck(err)
	if resp.StatusCode > 400 {
		resp, err = http.Get(target)
		errCheck(err)
	}

	if resp.StatusCode > 400 {
		fmt.Println("[!] Status code: " + strconv.Itoa(resp.StatusCode) + " | The page couldn't load!")
		l.Printf("[WARN] Couldn't load page - HTTP Status: %d - DirListing Passed", resp.StatusCode)
	} else if resp.StatusCode == 200 {
		doc, err := goquery.NewDocumentFromReader(resp.Body)

		defer resp.Body.Close()
		errCheck(err)
		title := doc.Find("title").Text()
		titleLower := strings.ToLower(title)

		if strings.Contains(titleLower, "index of") || strings.Contains(titleLower, "directory listing for ") {
			fmt.Println("[i] Title found: \"" + title + "\"\n[+] Dirlisting detected! --> URL: " + targetUrl)
			l.Println("[VULN] Dirlisting detected! --> URL: " + targetUrl)
		}

	} else {
		fmt.Println("[i] Redirection detected.")
		l.Printf("[WARN] Couldn't load page - HTTP Status: %d - Possible Redirection [DirListing]", resp.StatusCode)
	}

}

func LoginPageFinder(target string) {
	createRootURL(target)
	l.Println("[INFO] Detecting the is a login page or not...")
	re, err := regexp.Compile("Giriş|Kullanıcı Adı|Parola|Doğrulama Kodu|Yönetim Paneli|Login|Log in|log in|Log In|log In|LOG IN|login|LOGIN|Giriş|Giris|giris|GİRİS|GIRIS|GİRİŞ|Kayıt Ol|Kayıt ol|Kaydol|kayıt ol|KAYIT O|kaydol|KAYDOL|oturum ac|OTURUM AÇ|Oturum Aç|oturum aç|Oturum Ac")
	errCheck(err)

	resp, err := http.Get(targetUrl)
	errCheck(err)
	if resp.StatusCode > 400 {
		resp, err = http.Get(target)
		errCheck(err)
	}

	if resp.StatusCode > 400 {
		fmt.Println("[!] Status code: " + strconv.Itoa(resp.StatusCode) + " | The page couldn't load!")
		l.Printf("[WARN] Couldn't load page - HTTP Status: %d - LoginChecker Passed", resp.StatusCode)
	} else if resp.StatusCode == 200 {
		// Check the page is include login keywords and "<input"
		doc, err := goquery.NewDocumentFromReader(resp.Body)
		errCheck(err)

		body := doc.Find("body")
		html, err := body.Html()
		errCheck(err)

		if strings.Contains(html, "<input") {
			if re.FindString(html) != "" {
				fmt.Println("[+] This page might be a login page: " + targetUrl)
				l.Println("[RISK] This page might be a login page: " + targetUrl)
			}
		}

	} else {
		return
	}

}

func TraceDetector(target string) {
	createRootURL(target)
	client := &http.Client{}

	req, err := http.NewRequest("TRACE", target, nil)
	errCheck(err)
	resp, err := client.Do(req)
	errCheck(err)
	if resp.StatusCode > 400 {
		req, err := http.NewRequest("TRACE", targetUrl, nil)
		errCheck(err)
		resp, err = client.Do(req)
		errCheck(err)
	}

	defer resp.Body.Close()

	if resp.StatusCode > 400 {
		fmt.Println("[!] Status code: " + strconv.Itoa(resp.StatusCode) + " | TRACE method doesn't allowed!")
		l.Printf("[WARN] Couldn't load page - HTTP Status: %d - TraceDetector Passed", resp.StatusCode)
	} else if resp.StatusCode == 200 {
		fmt.Println("[+] TRACE method is allowed: " + targetUrl)
		l.Println("[VULN] TRACE method is allowed: " + targetUrl)

	} else {
		fmt.Println("[i] Redirection detected. ")
		l.Printf("[WARN] Couldn't load page - HTTP Status: %d - Possible Redirection [TraceDetector]", resp.StatusCode)

	}
}

func ServerDetector(target string) {
	createRootURL(target)
	l.Println("[INFO] Attacking for Server Header Information Disclosure.")

	resp, err := http.Get(targetUrl)
	errCheck(err)
	if resp.StatusCode > 400 {
		resp, err = http.Get(target)
		errCheck(err)
	}

	server_header := resp.Header.Get("Server")
	l.Printf("[INFO] Server header detected: %s | Checking for version information...", server_header)

	//Regex for numbers
	re := regexp.MustCompile(`[-]?\d[\d,]*[\.]?[\d{2}]*`)
	if re.MatchString(server_header) {
		l.Printf("[VULN] Server Header Version Information Disclosure detected: %s ", server_header)
		fmt.Printf("[+] Server Header Version Information Disclosure detected: %s ", server_header)
	}
}

func XFrameOptionsHeader(target string) {
	createRootURL(target)
	l.Println("[INFO] Attacking for Missing X-Frame-Options Header")

	resp, err := http.Get(targetUrl)
	errCheck(err)
	if resp.StatusCode > 400 {
		resp, err = http.Get(target)
		errCheck(err)
	}

	x_frame_options_h := resp.Header.Get("X-Frame-Options")
	if x_frame_options_h != "" {
		l.Printf("[i] X-Frame-Options header detected: %s ", x_frame_options_h)
		fmt.Printf("[i] X-Frame-Options header detected: %s ", x_frame_options_h)
	} else {
		l.Println("[VULN] Missing X-Frame-Options: The header couldn't detect.")
		fmt.Println("[+] Missing X-Frame-Options Header vulnerability detected.")
	}
}

func HSTS(target string) {
	createRootURL(target)
	l.Println("[INFO] Attacking for Missing HTTP Strict-Transport-Security (HSTS) header.")

	resp, err := http.Get(targetUrl)
	errCheck(err)
	if resp.StatusCode > 400 {
		resp, err = http.Get(target)
		errCheck(err)
	}

	hsts_h := resp.Header.Get("Strict-Transport-Security")
	if hsts_h != "" {
		l.Printf("[i] Strict-Transport-Security detected: %s ", hsts_h)
		fmt.Printf("[i] Strict-Transport-Security detected: %s ", hsts_h)
	} else {
		l.Println("[VULN] Strict-Transport-Security: The header couldn't detect.")
		fmt.Println("[+] Strict-Transport-Security Header vulnerability detected.")
	}
}
